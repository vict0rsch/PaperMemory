(function () {
    function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    var c = "function" == typeof require && require;
                    if (!f && c) return c(i, !0);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw ((a.code = "MODULE_NOT_FOUND"), a);
                }
                var p = (n[i] = { exports: {} });
                e[i][0].call(
                    p.exports,
                    function (r) {
                        var n = e[i][1][r];
                        return o(n || r);
                    },
                    p,
                    p.exports,
                    r,
                    e,
                    n,
                    t
                );
            }
            return n[i].exports;
        }
        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++)
            o(t[i]);
        return o;
    }
    return r;
})()(
    {
        1: [
            function (require, module, exports) {
                // shim for using process in browser
                var process = (module.exports = {});

                // cached from whatever global is present so that test runners that stub it
                // don't break things.  But we need to wrap it in a try catch in case it is
                // wrapped in strict mode code which doesn't define any globals.  It's inside a
                // function because try/catches deoptimize in certain engines.

                var cachedSetTimeout;
                var cachedClearTimeout;

                function defaultSetTimeout() {
                    throw new Error("setTimeout has not been defined");
                }
                function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined");
                }
                (function () {
                    try {
                        if (typeof setTimeout === "function") {
                            cachedSetTimeout = setTimeout;
                        } else {
                            cachedSetTimeout = defaultSetTimeout;
                        }
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimeout;
                    }
                    try {
                        if (typeof clearTimeout === "function") {
                            cachedClearTimeout = clearTimeout;
                        } else {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout;
                    }
                })();
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        //normal environments in sane situations
                        return setTimeout(fun, 0);
                    }
                    // if setTimeout wasn't available but was latter defined
                    if (
                        (cachedSetTimeout === defaultSetTimeout || !cachedSetTimeout) &&
                        setTimeout
                    ) {
                        cachedSetTimeout = setTimeout;
                        return setTimeout(fun, 0);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. madness
                        return cachedSetTimeout(fun, 0);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                            return cachedSetTimeout.call(null, fun, 0);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopefully our context correct otherwise it will throw a global error
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        //normal environments in sane situations
                        return clearTimeout(marker);
                    }
                    // if clearTimeout wasn't available but was latter defined
                    if (
                        (cachedClearTimeout === defaultClearTimeout ||
                            !cachedClearTimeout) &&
                        clearTimeout
                    ) {
                        cachedClearTimeout = clearTimeout;
                        return clearTimeout(marker);
                    }
                    try {
                        // when when somebody has screwed with setTimeout but no I.E. madness
                        return cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            // same as above but when it's a version of I.E. that must have the global object for 'this', hopefully our context correct otherwise it will throw a global error.
                            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;

                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    } else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }

                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;

                    var len = queue.length;
                    while (len) {
                        currentQueue = queue;
                        queue = [];
                        while (++queueIndex < len) {
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }

                process.nextTick = function (fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for (var i = 1; i < arguments.length; i++) {
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };

                // v8 likes predictable objects
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function () {
                    this.fun.apply(null, this.array);
                };
                process.title = "browser";
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = ""; // empty string to avoid regexp issues
                process.versions = {};

                function noop() {}

                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.prependListener = noop;
                process.prependOnceListener = noop;

                process.listeners = function (name) {
                    return [];
                };

                process.binding = function (name) {
                    throw new Error("process.binding is not supported");
                };

                process.cwd = function () {
                    return "/";
                };
                process.chdir = function (dir) {
                    throw new Error("process.chdir is not supported");
                };
                process.umask = function () {
                    return 0;
                };
            },
            {},
        ],
        2: [
            function (require, module, exports) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                    value: true,
                });
                exports.endpoint = void 0;
                var _universalUserAgent = require("universal-user-agent");
                // pkg/dist-src/defaults.js

                // pkg/dist-src/version.js
                var VERSION = "9.0.4";

                // pkg/dist-src/defaults.js
                var userAgent = `octokit-endpoint.js/${VERSION} ${(0,
                _universalUserAgent.getUserAgent)()}`;
                var DEFAULTS = {
                    method: "GET",
                    baseUrl: "https://api.github.com",
                    headers: {
                        accept: "application/vnd.github.v3+json",
                        "user-agent": userAgent,
                    },
                    mediaType: {
                        format: "",
                    },
                };

                // pkg/dist-src/util/lowercase-keys.js
                function lowercaseKeys(object) {
                    if (!object) {
                        return {};
                    }
                    return Object.keys(object).reduce((newObj, key) => {
                        newObj[key.toLowerCase()] = object[key];
                        return newObj;
                    }, {});
                }

                // pkg/dist-src/util/is-plain-object.js
                function isPlainObject(value) {
                    if (typeof value !== "object" || value === null) return false;
                    if (Object.prototype.toString.call(value) !== "[object Object]")
                        return false;
                    const proto = Object.getPrototypeOf(value);
                    if (proto === null) return true;
                    const Ctor =
                        Object.prototype.hasOwnProperty.call(proto, "constructor") &&
                        proto.constructor;
                    return (
                        typeof Ctor === "function" &&
                        Ctor instanceof Ctor &&
                        Function.prototype.call(Ctor) === Function.prototype.call(value)
                    );
                }

                // pkg/dist-src/util/merge-deep.js
                function mergeDeep(defaults, options) {
                    const result = Object.assign({}, defaults);
                    Object.keys(options).forEach((key) => {
                        if (isPlainObject(options[key])) {
                            if (!(key in defaults))
                                Object.assign(result, {
                                    [key]: options[key],
                                });
                            else result[key] = mergeDeep(defaults[key], options[key]);
                        } else {
                            Object.assign(result, {
                                [key]: options[key],
                            });
                        }
                    });
                    return result;
                }

                // pkg/dist-src/util/remove-undefined-properties.js
                function removeUndefinedProperties(obj) {
                    for (const key in obj) {
                        if (obj[key] === void 0) {
                            delete obj[key];
                        }
                    }
                    return obj;
                }

                // pkg/dist-src/merge.js
                function merge(defaults, route, options) {
                    if (typeof route === "string") {
                        let [method, url] = route.split(" ");
                        options = Object.assign(
                            url
                                ? {
                                      method,
                                      url,
                                  }
                                : {
                                      url: method,
                                  },
                            options
                        );
                    } else {
                        options = Object.assign({}, route);
                    }
                    options.headers = lowercaseKeys(options.headers);
                    removeUndefinedProperties(options);
                    removeUndefinedProperties(options.headers);
                    const mergedOptions = mergeDeep(defaults || {}, options);
                    if (options.url === "/graphql") {
                        if (defaults && defaults.mediaType.previews?.length) {
                            mergedOptions.mediaType.previews =
                                defaults.mediaType.previews
                                    .filter(
                                        (preview) =>
                                            !mergedOptions.mediaType.previews.includes(
                                                preview
                                            )
                                    )
                                    .concat(mergedOptions.mediaType.previews);
                        }
                        mergedOptions.mediaType.previews = (
                            mergedOptions.mediaType.previews || []
                        ).map((preview) => preview.replace(/-preview/, ""));
                    }
                    return mergedOptions;
                }

                // pkg/dist-src/util/add-query-parameters.js
                function addQueryParameters(url, parameters) {
                    const separator = /\?/.test(url) ? "&" : "?";
                    const names = Object.keys(parameters);
                    if (names.length === 0) {
                        return url;
                    }
                    return (
                        url +
                        separator +
                        names
                            .map((name) => {
                                if (name === "q") {
                                    return (
                                        "q=" +
                                        parameters.q
                                            .split("+")
                                            .map(encodeURIComponent)
                                            .join("+")
                                    );
                                }
                                return `${name}=${encodeURIComponent(
                                    parameters[name]
                                )}`;
                            })
                            .join("&")
                    );
                }

                // pkg/dist-src/util/extract-url-variable-names.js
                var urlVariableRegex = /\{[^}]+\}/g;
                function removeNonChars(variableName) {
                    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
                }
                function extractUrlVariableNames(url) {
                    const matches = url.match(urlVariableRegex);
                    if (!matches) {
                        return [];
                    }
                    return matches
                        .map(removeNonChars)
                        .reduce((a, b) => a.concat(b), []);
                }

                // pkg/dist-src/util/omit.js
                function omit(object, keysToOmit) {
                    const result = {
                        __proto__: null,
                    };
                    for (const key of Object.keys(object)) {
                        if (keysToOmit.indexOf(key) === -1) {
                            result[key] = object[key];
                        }
                    }
                    return result;
                }

                // pkg/dist-src/util/url-template.js
                function encodeReserved(str) {
                    return str
                        .split(/(%[0-9A-Fa-f]{2})/g)
                        .map(function (part) {
                            if (!/%[0-9A-Fa-f]/.test(part)) {
                                part = encodeURI(part)
                                    .replace(/%5B/g, "[")
                                    .replace(/%5D/g, "]");
                            }
                            return part;
                        })
                        .join("");
                }
                function encodeUnreserved(str) {
                    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
                        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
                    });
                }
                function encodeValue(operator, value, key) {
                    value =
                        operator === "+" || operator === "#"
                            ? encodeReserved(value)
                            : encodeUnreserved(value);
                    if (key) {
                        return encodeUnreserved(key) + "=" + value;
                    } else {
                        return value;
                    }
                }
                function isDefined(value) {
                    return value !== void 0 && value !== null;
                }
                function isKeyOperator(operator) {
                    return operator === ";" || operator === "&" || operator === "?";
                }
                function getValues(context, operator, key, modifier) {
                    var value = context[key],
                        result = [];
                    if (isDefined(value) && value !== "") {
                        if (
                            typeof value === "string" ||
                            typeof value === "number" ||
                            typeof value === "boolean"
                        ) {
                            value = value.toString();
                            if (modifier && modifier !== "*") {
                                value = value.substring(0, parseInt(modifier, 10));
                            }
                            result.push(
                                encodeValue(
                                    operator,
                                    value,
                                    isKeyOperator(operator) ? key : ""
                                )
                            );
                        } else {
                            if (modifier === "*") {
                                if (Array.isArray(value)) {
                                    value.filter(isDefined).forEach(function (value2) {
                                        result.push(
                                            encodeValue(
                                                operator,
                                                value2,
                                                isKeyOperator(operator) ? key : ""
                                            )
                                        );
                                    });
                                } else {
                                    Object.keys(value).forEach(function (k) {
                                        if (isDefined(value[k])) {
                                            result.push(
                                                encodeValue(operator, value[k], k)
                                            );
                                        }
                                    });
                                }
                            } else {
                                const tmp = [];
                                if (Array.isArray(value)) {
                                    value.filter(isDefined).forEach(function (value2) {
                                        tmp.push(encodeValue(operator, value2));
                                    });
                                } else {
                                    Object.keys(value).forEach(function (k) {
                                        if (isDefined(value[k])) {
                                            tmp.push(encodeUnreserved(k));
                                            tmp.push(
                                                encodeValue(
                                                    operator,
                                                    value[k].toString()
                                                )
                                            );
                                        }
                                    });
                                }
                                if (isKeyOperator(operator)) {
                                    result.push(
                                        encodeUnreserved(key) + "=" + tmp.join(",")
                                    );
                                } else if (tmp.length !== 0) {
                                    result.push(tmp.join(","));
                                }
                            }
                        }
                    } else {
                        if (operator === ";") {
                            if (isDefined(value)) {
                                result.push(encodeUnreserved(key));
                            }
                        } else if (
                            value === "" &&
                            (operator === "&" || operator === "?")
                        ) {
                            result.push(encodeUnreserved(key) + "=");
                        } else if (value === "") {
                            result.push("");
                        }
                    }
                    return result;
                }
                function parseUrl(template) {
                    return {
                        expand: expand.bind(null, template),
                    };
                }
                function expand(template, context) {
                    var operators = ["+", "#", ".", "/", ";", "?", "&"];
                    template = template.replace(
                        /\{([^\{\}]+)\}|([^\{\}]+)/g,
                        function (_, expression, literal) {
                            if (expression) {
                                let operator = "";
                                const values = [];
                                if (operators.indexOf(expression.charAt(0)) !== -1) {
                                    operator = expression.charAt(0);
                                    expression = expression.substr(1);
                                }
                                expression.split(/,/g).forEach(function (variable) {
                                    var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(
                                        variable
                                    );
                                    values.push(
                                        getValues(
                                            context,
                                            operator,
                                            tmp[1],
                                            tmp[2] || tmp[3]
                                        )
                                    );
                                });
                                if (operator && operator !== "+") {
                                    var separator = ",";
                                    if (operator === "?") {
                                        separator = "&";
                                    } else if (operator !== "#") {
                                        separator = operator;
                                    }
                                    return (
                                        (values.length !== 0 ? operator : "") +
                                        values.join(separator)
                                    );
                                } else {
                                    return values.join(",");
                                }
                            } else {
                                return encodeReserved(literal);
                            }
                        }
                    );
                    if (template === "/") {
                        return template;
                    } else {
                        return template.replace(/\/$/, "");
                    }
                }

                // pkg/dist-src/parse.js
                function parse(options) {
                    let method = options.method.toUpperCase();
                    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
                    let headers = Object.assign({}, options.headers);
                    let body;
                    let parameters = omit(options, [
                        "method",
                        "baseUrl",
                        "url",
                        "headers",
                        "request",
                        "mediaType",
                    ]);
                    const urlVariableNames = extractUrlVariableNames(url);
                    url = parseUrl(url).expand(parameters);
                    if (!/^http/.test(url)) {
                        url = options.baseUrl + url;
                    }
                    const omittedParameters = Object.keys(options)
                        .filter((option) => urlVariableNames.includes(option))
                        .concat("baseUrl");
                    const remainingParameters = omit(parameters, omittedParameters);
                    const isBinaryRequest = /application\/octet-stream/i.test(
                        headers.accept
                    );
                    if (!isBinaryRequest) {
                        if (options.mediaType.format) {
                            headers.accept = headers.accept
                                .split(/,/)
                                .map((format) =>
                                    format.replace(
                                        /application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,
                                        `application/vnd$1$2.${options.mediaType.format}`
                                    )
                                )
                                .join(",");
                        }
                        if (url.endsWith("/graphql")) {
                            if (options.mediaType.previews?.length) {
                                const previewsFromAcceptHeader =
                                    headers.accept.match(/[\w-]+(?=-preview)/g) || [];
                                headers.accept = previewsFromAcceptHeader
                                    .concat(options.mediaType.previews)
                                    .map((preview) => {
                                        const format = options.mediaType.format
                                            ? `.${options.mediaType.format}`
                                            : "+json";
                                        return `application/vnd.github.${preview}-preview${format}`;
                                    })
                                    .join(",");
                            }
                        }
                    }
                    if (["GET", "HEAD"].includes(method)) {
                        url = addQueryParameters(url, remainingParameters);
                    } else {
                        if ("data" in remainingParameters) {
                            body = remainingParameters.data;
                        } else {
                            if (Object.keys(remainingParameters).length) {
                                body = remainingParameters;
                            }
                        }
                    }
                    if (!headers["content-type"] && typeof body !== "undefined") {
                        headers["content-type"] = "application/json; charset=utf-8";
                    }
                    if (
                        ["PATCH", "PUT"].includes(method) &&
                        typeof body === "undefined"
                    ) {
                        body = "";
                    }
                    return Object.assign(
                        {
                            method,
                            url,
                            headers,
                        },
                        typeof body !== "undefined"
                            ? {
                                  body,
                              }
                            : null,
                        options.request
                            ? {
                                  request: options.request,
                              }
                            : null
                    );
                }

                // pkg/dist-src/endpoint-with-defaults.js
                function endpointWithDefaults(defaults, route, options) {
                    return parse(merge(defaults, route, options));
                }

                // pkg/dist-src/with-defaults.js
                function withDefaults(oldDefaults, newDefaults) {
                    const DEFAULTS2 = merge(oldDefaults, newDefaults);
                    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
                    return Object.assign(endpoint2, {
                        DEFAULTS: DEFAULTS2,
                        defaults: withDefaults.bind(null, DEFAULTS2),
                        merge: merge.bind(null, DEFAULTS2),
                        parse,
                    });
                }

                // pkg/dist-src/index.js
                var endpoint = (exports.endpoint = withDefaults(null, DEFAULTS));
            },
            { "universal-user-agent": 7 },
        ],
        3: [
            function (require, module, exports) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                    value: true,
                });
                exports.RequestError = void 0;
                var _deprecation = require("deprecation");
                var _once = _interopRequireDefault(require("once"));
                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { default: obj };
                }
                // pkg/dist-src/index.js

                var logOnceCode = (0, _once.default)((deprecation) =>
                    console.warn(deprecation)
                );
                var logOnceHeaders = (0, _once.default)((deprecation) =>
                    console.warn(deprecation)
                );
                var RequestError = class extends Error {
                    constructor(message, statusCode, options) {
                        super(message);
                        if (Error.captureStackTrace) {
                            Error.captureStackTrace(this, this.constructor);
                        }
                        this.name = "HttpError";
                        this.status = statusCode;
                        let headers;
                        if (
                            "headers" in options &&
                            typeof options.headers !== "undefined"
                        ) {
                            headers = options.headers;
                        }
                        if ("response" in options) {
                            this.response = options.response;
                            headers = options.response.headers;
                        }
                        const requestCopy = Object.assign({}, options.request);
                        if (options.request.headers.authorization) {
                            requestCopy.headers = Object.assign(
                                {},
                                options.request.headers,
                                {
                                    authorization:
                                        options.request.headers.authorization.replace(
                                            / .*$/,
                                            " [REDACTED]"
                                        ),
                                }
                            );
                        }
                        requestCopy.url = requestCopy.url
                            .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]")
                            .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
                        this.request = requestCopy;
                        Object.defineProperty(this, "code", {
                            get() {
                                logOnceCode(
                                    new _deprecation.Deprecation(
                                        "[@octokit/request-error] `error.code` is deprecated, use `error.status`."
                                    )
                                );
                                return statusCode;
                            },
                        });
                        Object.defineProperty(this, "headers", {
                            get() {
                                logOnceHeaders(
                                    new _deprecation.Deprecation(
                                        "[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."
                                    )
                                );
                                return headers || {};
                            },
                        });
                    }
                };
                exports.RequestError = RequestError;
            },
            { deprecation: 5, once: 6 },
        ],
        4: [
            function (require, module, exports) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                    value: true,
                });
                exports.request = void 0;
                var _endpoint = require("@octokit/endpoint");
                var _universalUserAgent = require("universal-user-agent");
                var _requestError = require("@octokit/request-error");
                // pkg/dist-src/index.js

                // pkg/dist-src/version.js
                var VERSION = "8.1.6";

                // pkg/dist-src/is-plain-object.js
                function isPlainObject(value) {
                    if (typeof value !== "object" || value === null) return false;
                    if (Object.prototype.toString.call(value) !== "[object Object]")
                        return false;
                    const proto = Object.getPrototypeOf(value);
                    if (proto === null) return true;
                    const Ctor =
                        Object.prototype.hasOwnProperty.call(proto, "constructor") &&
                        proto.constructor;
                    return (
                        typeof Ctor === "function" &&
                        Ctor instanceof Ctor &&
                        Function.prototype.call(Ctor) === Function.prototype.call(value)
                    );
                }

                // pkg/dist-src/fetch-wrapper.js

                // pkg/dist-src/get-buffer-response.js
                function getBufferResponse(response) {
                    return response.arrayBuffer();
                }

                // pkg/dist-src/fetch-wrapper.js
                function fetchWrapper(requestOptions) {
                    const log =
                        requestOptions.request && requestOptions.request.log
                            ? requestOptions.request.log
                            : console;
                    const parseSuccessResponseBody =
                        requestOptions.request?.parseSuccessResponseBody !== false;
                    if (
                        isPlainObject(requestOptions.body) ||
                        Array.isArray(requestOptions.body)
                    ) {
                        requestOptions.body = JSON.stringify(requestOptions.body);
                    }
                    let headers = {};
                    let status;
                    let url;
                    let { fetch } = globalThis;
                    if (requestOptions.request?.fetch) {
                        fetch = requestOptions.request.fetch;
                    }
                    if (!fetch) {
                        throw new Error(
                            "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
                        );
                    }
                    return fetch(requestOptions.url, {
                        method: requestOptions.method,
                        body: requestOptions.body,
                        headers: requestOptions.headers,
                        signal: requestOptions.request?.signal,
                        // duplex must be set if request.body is ReadableStream or Async Iterables.
                        // See https://fetch.spec.whatwg.org/#dom-requestinit-duplex.
                        ...(requestOptions.body && {
                            duplex: "half",
                        }),
                    })
                        .then(async (response) => {
                            url = response.url;
                            status = response.status;
                            for (const keyAndValue of response.headers) {
                                headers[keyAndValue[0]] = keyAndValue[1];
                            }
                            if ("deprecation" in headers) {
                                const matches =
                                    headers.link &&
                                    headers.link.match(/<([^>]+)>; rel="deprecation"/);
                                const deprecationLink = matches && matches.pop();
                                log.warn(
                                    `[@octokit/request] "${requestOptions.method} ${
                                        requestOptions.url
                                    }" is deprecated. It is scheduled to be removed on ${
                                        headers.sunset
                                    }${
                                        deprecationLink
                                            ? `. See ${deprecationLink}`
                                            : ""
                                    }`
                                );
                            }
                            if (status === 204 || status === 205) {
                                return;
                            }
                            if (requestOptions.method === "HEAD") {
                                if (status < 400) {
                                    return;
                                }
                                throw new _requestError.RequestError(
                                    response.statusText,
                                    status,
                                    {
                                        response: {
                                            url,
                                            status,
                                            headers,
                                            data: void 0,
                                        },
                                        request: requestOptions,
                                    }
                                );
                            }
                            if (status === 304) {
                                throw new _requestError.RequestError(
                                    "Not modified",
                                    status,
                                    {
                                        response: {
                                            url,
                                            status,
                                            headers,
                                            data: await getResponseData(response),
                                        },
                                        request: requestOptions,
                                    }
                                );
                            }
                            if (status >= 400) {
                                const data = await getResponseData(response);
                                const error = new _requestError.RequestError(
                                    toErrorMessage(data),
                                    status,
                                    {
                                        response: {
                                            url,
                                            status,
                                            headers,
                                            data,
                                        },
                                        request: requestOptions,
                                    }
                                );
                                throw error;
                            }
                            return parseSuccessResponseBody
                                ? await getResponseData(response)
                                : response.body;
                        })
                        .then((data) => {
                            return {
                                status,
                                url,
                                headers,
                                data,
                            };
                        })
                        .catch((error) => {
                            if (error instanceof _requestError.RequestError)
                                throw error;
                            else if (error.name === "AbortError") throw error;
                            let message = error.message;
                            if (error.name === "TypeError" && "cause" in error) {
                                if (error.cause instanceof Error) {
                                    message = error.cause.message;
                                } else if (typeof error.cause === "string") {
                                    message = error.cause;
                                }
                            }
                            throw new _requestError.RequestError(message, 500, {
                                request: requestOptions,
                            });
                        });
                }
                async function getResponseData(response) {
                    const contentType = response.headers.get("content-type");
                    if (/application\/json/.test(contentType)) {
                        return response
                            .json()
                            .catch(() => response.text())
                            .catch(() => "");
                    }
                    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
                        return response.text();
                    }
                    return getBufferResponse(response);
                }
                function toErrorMessage(data) {
                    if (typeof data === "string") return data;
                    if ("message" in data) {
                        if (Array.isArray(data.errors)) {
                            return `${data.message}: ${data.errors
                                .map(JSON.stringify)
                                .join(", ")}`;
                        }
                        return data.message;
                    }
                    return `Unknown error: ${JSON.stringify(data)}`;
                }

                // pkg/dist-src/with-defaults.js
                function withDefaults(oldEndpoint, newDefaults) {
                    const endpoint2 = oldEndpoint.defaults(newDefaults);
                    const newApi = function (route, parameters) {
                        const endpointOptions = endpoint2.merge(route, parameters);
                        if (!endpointOptions.request || !endpointOptions.request.hook) {
                            return fetchWrapper(endpoint2.parse(endpointOptions));
                        }
                        const request2 = (route2, parameters2) => {
                            return fetchWrapper(
                                endpoint2.parse(endpoint2.merge(route2, parameters2))
                            );
                        };
                        Object.assign(request2, {
                            endpoint: endpoint2,
                            defaults: withDefaults.bind(null, endpoint2),
                        });
                        return endpointOptions.request.hook(request2, endpointOptions);
                    };
                    return Object.assign(newApi, {
                        endpoint: endpoint2,
                        defaults: withDefaults.bind(null, endpoint2),
                    });
                }

                // pkg/dist-src/index.js
                var request = (exports.request = withDefaults(_endpoint.endpoint, {
                    headers: {
                        "user-agent": `octokit-request.js/${VERSION} ${(0,
                        _universalUserAgent.getUserAgent)()}`,
                    },
                }));
            },
            {
                "@octokit/endpoint": 2,
                "@octokit/request-error": 3,
                "universal-user-agent": 7,
            },
        ],
        5: [
            function (require, module, exports) {
                "use strict";

                Object.defineProperty(exports, "__esModule", {
                    value: true,
                });
                exports.Deprecation = void 0;
                class Deprecation extends Error {
                    constructor(message) {
                        super(message); // Maintains proper stack trace (only available on V8)

                        /* istanbul ignore next */

                        if (Error.captureStackTrace) {
                            Error.captureStackTrace(this, this.constructor);
                        }
                        this.name = "Deprecation";
                    }
                }
                exports.Deprecation = Deprecation;
            },
            {},
        ],
        6: [
            function (require, module, exports) {
                var wrappy = require("wrappy");
                module.exports = wrappy(once);
                module.exports.strict = wrappy(onceStrict);

                once.proto = once(function () {
                    Object.defineProperty(Function.prototype, "once", {
                        value: function () {
                            return once(this);
                        },
                        configurable: true,
                    });

                    Object.defineProperty(Function.prototype, "onceStrict", {
                        value: function () {
                            return onceStrict(this);
                        },
                        configurable: true,
                    });
                });

                function once(fn) {
                    var f = function () {
                        if (f.called) return f.value;
                        f.called = true;
                        return (f.value = fn.apply(this, arguments));
                    };
                    f.called = false;
                    return f;
                }

                function onceStrict(fn) {
                    var f = function () {
                        if (f.called) throw new Error(f.onceError);
                        f.called = true;
                        return (f.value = fn.apply(this, arguments));
                    };
                    var name = fn.name || "Function wrapped with `once`";
                    f.onceError = name + " shouldn't be called more than once";
                    f.called = false;
                    return f;
                }
            },
            { wrappy: 8 },
        ],
        7: [
            function (require, module, exports) {
                (function (process) {
                    (function () {
                        "use strict";

                        Object.defineProperty(exports, "__esModule", {
                            value: true,
                        });
                        exports.getUserAgent = getUserAgent;
                        function getUserAgent() {
                            if (
                                typeof navigator === "object" &&
                                "userAgent" in navigator
                            ) {
                                return navigator.userAgent;
                            }
                            if (
                                typeof process === "object" &&
                                process.version !== undefined
                            ) {
                                return `Node.js/${process.version.substr(1)} (${
                                    process.platform
                                }; ${process.arch})`;
                            }
                            return "<environment undetectable>";
                        }
                    }).call(this);
                }).call(this, require("_process"));
            },
            { _process: 1 },
        ],
        8: [
            function (require, module, exports) {
                // Returns a wrapper function that returns a wrapped callback
                // The wrapper function should do some stuff, and return a
                // presumably different callback function.
                // This makes sure that own properties are retained, so that
                // decorations and such are not lost along the way.
                module.exports = wrappy;
                function wrappy(fn, cb) {
                    if (fn && cb) return wrappy(fn)(cb);

                    if (typeof fn !== "function")
                        throw new TypeError("need wrapper function");

                    Object.keys(fn).forEach(function (k) {
                        wrapper[k] = fn[k];
                    });

                    return wrapper;

                    function wrapper() {
                        var args = new Array(arguments.length);
                        for (var i = 0; i < args.length; i++) {
                            args[i] = arguments[i];
                        }
                        var ret = fn.apply(this, args);
                        var cb = args[args.length - 1];
                        if (typeof ret === "function" && ret !== cb) {
                            Object.keys(cb).forEach(function (k) {
                                ret[k] = cb[k];
                            });
                        }
                        return ret;
                    }
                }
            },
            {},
        ],
        9: [
            function (require, module, exports) {
                (function (global) {
                    (function () {
                        /**
                         * npm install @octokit/request
                         * npm install -g browserify
                         * npm install esmify
                         * browserify src/background/octokit.js -p esmify -o src/shared/js/utils/octokit.bundle.js
                         */
                        const { request } = require("@octokit/request");
                        if (typeof window === "undefined") {
                            window = global;
                        } else {
                            global = window;
                        }
                        global.octokitRequest = request;
                    }).call(this);
                }).call(
                    this,
                    typeof global !== "undefined"
                        ? global
                        : typeof self !== "undefined"
                        ? self
                        : typeof window !== "undefined"
                        ? window
                        : {}
                );
            },
            { "@octokit/request": 4 },
        ],
    },
    {},
    [9]
);
